* raytracker - building a small web-application with unusual technology choices

** Nixifying the frontend

Now that the server can be reproducibly built using just =nix-build=, let’s check what we can do for the client. Right now, we only have a =shell.nix= in the =frontend-concur= directory. When we activate the shell via =nix-shell=, what we get right now is:

- the =yarn= package manager
- =purs=, the Purescript compiler
- =spago=, Purescript’s package manager
- =purescript-language-server=

Notice that we don’t get any npm packages via Nix (except the ones mentioned). We also don’t have a =default.nix= that gives us a nice, reproducible =result= directory. Let’s try to fix that.

We would like to create a Nix derivation that:

- calls =yarn run prod= to build our HTML, JS and CSS files
- and puts those files into the Nix store, so we can later serve this on NixOS using nginx, for example

However, the Nix build phase doesn’t allow network access, and we would need to pull some npm dependencies in order to build the program. How do we do that? Let’s take a look at [[https://github.com/svanderburg/node2nix][node2nix]] and try it out.

It seems to be included in nixpkgs, so we should just be able to nix-shell into it and call it:

#+begin_example
> nix-shell -p nodePackages.node2nix --run node2nix

info attempt registry request try #1 at 12:06:24 PM
http request GET https://registry.npmjs.org/ansi-styles
http 200 https://registry.npmjs.org/ansi-styles
info attempt registry request try #1 at 12:06:24 PM
http request GET https://registry.npmjs.org/astral-regex
…

WARNING: There is a node_modules/ folder in the root directory of the project!
These packages will be included in the Nix build and influence the outcome.
If you don't want this to happen, then you should remove it before running any
of the Nix commands!
#+end_example

The output is a bit too long to include here, but it’s good that the tool warns us about the =node_modules= folder. Looking at =git status=, I see it has created three files: =default.nix=, =node-env.nix= and =node-packages.nix=.

The README tells us that we can use the generated files in order to bundle applications that need npm packages, which is exactly what we want to do! So, we write a little file, let’s call it =build-frontend.nix= for now, containing this:

#+begin_src nix
let
  nixpkgs = import (builtins.fetchTarball {
    name = "nixos-unstable-2021-11-20";
    url = "https://github.com/nixos/nixpkgs/archive/a03719be2e676041847e1b59dafa8ab668fa2d2a.tar.gz";
    sha256 = "1xvcc89m80cpslv84qhbbcyvcjqxhip5drx1arxvaajqv9059nqk";
  }) {};
  nodeDependencies = (nixpkgs.callPackage ./default.nix {}).shell.nodeDependencies;
in

nixpkgs.stdenv.mkDerivation {
  name = "raytracker-frontend-concur";
  src = ./.;
  buildInputs = [ nixpkgs.yarn ];
  buildPhase = ''
    ln -s ${nodeDependencies}/lib/node_modules ./node_modules
    export PATH="${nodeDependencies}/bin:$PATH"

    yarn run prod
  '';
}
#+end_src

The important bit is:

#+begin_src nix
nodeDependencies = (nixpkgs.callPackage ./default.nix {}).shell.nodeDependencies;
#+end_src

which uses the =default.nix= generated by =node2nix= to retrieve the dependencies we have in our =package.json=. We should now be able to just =nix-build build-frontend.nix=:

#+begin_example
> nix-build build-frontend.nix

…lots of output

sh: node-gyp-build: command not found
npm ERR! code ELIFECYCLE
npm ERR! syscall spawn
npm ERR! file sh
npm ERR! errno ENOENT
npm ERR! lmdb-store@1.6.14 install: `node-gyp-build`
npm ERR! spawn ENOENT
#+end_example

What’s =node-gyp-build=? No idea. Googling gives me the [[https://github.com/nodejs/node-gyp][node-gyp]] project which is:

#+begin_quote
node-gyp is a cross-platform command-line tool written in Node.js for compiling native addon modules for Node.js. It contains a vendored copy of the gyp-next project that was previously used by the Chromium team, extended to support the development of Node.js native addons.
#+end_quote

Aha, okay, and that’s missing? Maybe it’s because I’m using yarn and thus have no =package-lock.json= file which node2nix could use? But the [[https://github.com/svanderburg/node2nix#adding-additionalglobal-npm-packages-to-a-packaging-process][node2nix readme]] has a possible solution to the =node-gyp-build= problem. I’m going to create a =supplemental.json= file containing the additional dependency:

#+begin_src json
[
  {
    "node-gyp-build": "4.3.0"
  }
]
#+end_src

And then re-run node2nix with the suggested parameters =-d -i package.json --supplement-input supplemental.json=. And indeed, running =nix-build build-frontend.nix= again:

#+begin_example
sh: /nix/store/dg8957qnsi459smh11i01y2k3580zg0l-node-dependencies-raytracker-1.0.0/raytracker/node_modules/.bin/node-gyp-build: /usr/bin/env: bad interpreter: No such file or directory
npm ERR! code ELIFECYCLE
npm ERR! errno 126
npm ERR! @parcel/watcher@2.0.2 install: `node-gyp-build`
npm ERR! Exit status 126
npm ERR!
npm ERR! Failed at the @parcel/watcher@2.0.2 install script.
#+end_example

At least we got rid of that lmdb-store message, right? I’m very wary of this =bad interpreter= message. This usually means we’re using a binary of some sort instead of a Nix package version or at least a Nix-patched binary.

Digging deeper into this, [[https://github.com/svanderburg/node2nix/issues/198][there is an issue]] open on the node2nix issue tracker where people have similar problems. It’s suggested to edit the =build-frontend.nix= file and specify the node dependencies as follows:

#+begin_src nix
nodeDependencies = (nixpkgs.callPackage ({ pkgs, system }:
  let nodePackages = import ./default.nix { inherit pkgs system; };
  in nodePackages // {
    "@parcel/watcher" = nodePackages."@parcel/watcher".override {
      buildInputs = [ pkgs.nodePackages.node-gyp-build ];
    };
  }
  ) {}).shell.nodeDependencies;
#+end_src

So we’re specifying =pkgs.nodePackages.node-gyp-build= (i.e. the Nix version of =node-gyp-build=) instead of the npm package. Which sucks, since the Nix package might have a different version than the one specific in the dependencies of =parcel=. But okay, let’s try:

#+begin_example
> lmdb-store@1.6.14 install /nix/store/s4579wrn8qk17llvfhb231cny1ngj8vq-node-dependencies-raytracker-1.0.0/raytracker/node_modules/lmdb-store
> node-gyp-build

sh: line 1: node-gyp-build: command not found
npm ERR! code ELIFECYCLE
npm ERR! syscall spawn
npm ERR! file sh
npm ERR! errno ENOENT
npm ERR! lmdb-store@1.6.14 install: `node-gyp-build`
npm ERR! spawn ENOENT
#+end_example

Damn, =lmdb-store= again? Okay, maybe we can re-use our solution and extend the list of patched =buildInputs=:

#+begin_src nix
  nodeDependencies = (nixpkgs.callPackage ({ pkgs, system }:
    let nodePackages = import ./default.nix { inherit pkgs system; };
    in nodePackages // {
      "@parcel/watcher" = nodePackages."@parcel/watcher".override {
        buildInputs = [ pkgs.nodePackages.node-gyp-build ];
      };
      "lmdb-store" = nodePackages."lmdb-store".override {
        buildInputs = [ pkgs.nodePackages.node-gyp-build ];
      };
    }
    ) {}).shell.nodeDependencies;
#+end_src

But running =nix-build build-frontend.nix=, same error message. So I’m stuck. Or am I? There is [[https://github.com/svanderburg/node2nix/pull/266][a pull request]] on the node2nix repository which aims to patch the shebang lines, and names =node-gyp-build= as an example where this might be useful. Okay, how do I apply this PR? Let’s write a little Nix expression for the patched version:

#+begin_src nix
let pkgs = import <nixpkgs> {};
in pkgs.nodePackages.node2nix.override {
  src = pkgs.fetchFromGitHub {
          owner = "thomasjm";
          repo = "node2nix";
          rev = "master";
          sha256 = "sha256-S1a87M3NHOXgAFDNVi2vXRbpDKZ/yZy9sUtwutDZBz0=";
        };
}
#+end_src

And isn’t this amazing? We can just patch the whole build process and specify a different source URL. Everything else works, just: =nix-build patched-node2nix.nix= and voila, we’ve got ourselves a brand-new =result/bin/node2nix=!

But does it work? Well:

#+begin_example
> result/bin/node2nix -l package-lock.json && nix-build build-frontend.nix

> lmdb-store@1.6.14 install /nix/store/kh8zggscl7cqqlp2crkjg801yh8lxdsd-node-dependencies-raytracker-1.0.0/raytracker/node_modules/lmdb-store
> node-gyp-build

sh: line 1: node-gyp-build: command not found
npm ERR! code ELIFECYCLE
npm ERR! syscall spawn
npm ERR! file sh
npm ERR! errno ENOENT
npm ERR! lmdb-store@1.6.14 install: `node-gyp-build`
#+end_example

Sigh. Okay. What I also found was [[https://discourse.nixos.org/t/dealing-with-node-packages-in-shells-and-derivations-for-static-front-end-distribution/13083/2][this Discourse thread]] explaining that you might have to do what I did, but overriding the =shell= (?!) package’s =buildInputs= to include =node-gyp-build=, so:

#+begin_src nix
  nodeDependencies = (nixpkgs.callPackage ({ pkgs, system }:
    let nodePackages = import ./default.nix { inherit pkgs system; };
    in nodePackages // {
      shell = nodePackages.shell.override {
        buildInputs = [ pkgs.nodePackages.node-gyp-build ];
      };
    }
    ) {}).shell.nodeDependencies;
#+end_src

And this /actually/ creates a different kind of error message:

#+begin_example
yarn run v1.22.17
warning You don't appear to have an internet connection. Try the --offline flag to use the cache for registry queries.
warning Skipping preferred cache folder "/homeless-shelter/.cache/yarn" because it is not writable.
warning Selected the next writable cache folder in the list, will be "/build/.yarn-cache-1000".
$ spago build && parcel build index.html
warning Cannot find a suitable global folder. Tried these: "/usr/local, /homeless-shelter/.yarn"
/bin/sh: spago: not found
error Command failed with exit code 127.
#+end_example

This is completely fine, since I didn’t specify =spago= in my =package.json=, it cannot magically find it. I can easily copy what I have in =shell.nix=, though, and add =spago= and =purs-0_14_5= into my =buildInputs=. There is, however, another error message coming up:

#+begin_example
[error] Directory "/" is not accessible. Permissions {readable = True, writable = False, executable = False, searchable = True}
#+end_example

So we’re trying to build our application in /, which is not writeable. Hm. Okay, Plan B!

Plan B involves simply running =yarn install= to get a =node_modules= directory, circumventing some of the reproducibility that Nix would bring us. This /should/ not be too difficult, and I remember having seen an example of a Maven-based program  doing just that. And sure enough, the [[https://nixos.org/manual/nixpkgs/stable/#maven][nixpkgs]] manual for “Maven” does have an example of doing that. The idea here is to have /two/ derivations: one just for the dependencies, and one for the actual program (which they call “Double invocation” in the manual). My dependency invocation looks like this:

#+begin_src nix
node-modules = pkgs.stdenv.mkDerivation rec {
  name = "raytracker-frontend-deps";

  src = pkgs.lib.cleanSource ./.;

  buildInputs = [
    pkgs.yarn
    pkgs.nodePackages.node-gyp-build
  ];

  buildPhase = ''
    yarn install --cache-folder . --use-yarnrc .yarnrc
  '';

  installPhase = ''
    mkdir -p $out
    cp -R node_modules $out/
  '';

  dontFixup = true;
  outputHashAlgo = "sha256";
  outputHashMode = "recursive";
  # replace this with the correct SHA256
  outputHash = "sha256-o17ba3KMQnkvbQK1Nqoe/z/95m6oyYHEkHGDzVkc1xo=";
};
#+end_src

Notice our friend =nodePackages.node-gyp-build= again, which is actually used to install =@parcel/watcher=, for example. Otherwise, we use =yarn= and specify a =.yarnrc=, because I couldn’t disable its usage and yarn needs it. The important parts are the latter lines:

- in the =installPhase=, we copy the =node_modules= directory (e.g. our dependencies) to =$out=
- and then specify the =outputHash= parameters. I /think/ this makes Nix forget about the “no internet” requirement

With that, our main derivation looks like this:

#+begin_src nix
pkgs.stdenv.mkDerivation rec {
  pname = "raytracker-frontend";
  version = "1.0.0";

  src = pkgs.lib.cleanSource ./.;

  buildInputs = [
    pkgs.yarn
    easy-ps.spago
    easy-ps.purs-0_14_5
  ];

  buildPhase = ''
    ln -s ${node-modules}/node_modules ./node_modules
    yarn --cache-folder .cache --offline run prod
  '';
}
#+end_src

Where we specified the =prod= script as follows in our =package.json=:

#+begin_src json
  "scripts": {
    "dev": "spago build && parcel serve index.html",
    "prod": "spago build && parcel build index.html"
  }
#+end_src

With that, let’s =nix-build=:

#+begin_example
> nix-build default.nix

$ spago build --no-install
warning Cannot find a suitable global folder. Tried these: "/usr/local, /homeless-shelter/.yarn"
[error] Directory "/" is not accessible. Permissions {readable = True, writable = False, executable = False, searchable = True}
error Command failed with exit code 1.
#+end_example

Ah, this pesky directory again. But this time, I dug a little deeper in to Google and found [[https://github.com/purescript/spago/issues/380][issue 380 in the spago repository]] which describes just this problem for Windows. The solution is to disable spago’s cache. Makes sense! Changing that to:

#+begin_src json
"scripts": {
  "dev": "spago build && parcel serve index.html",
  "prod": "spago build --global-cache=skip && parcel build index.html"
}
#+end_src

We get the following error:

#+begin_example
Warning: Could not get or create the default cache directory:

? /homeless-shelter/.cache/dhall

You can enable caching by creating it if needed and setting read,
write and search permissions on it or providing another cache base
directory by setting the $XDG_CACHE_HOME environment variable.


spago: 
Error: Remote host not found
#+end_example

And this /also/ makes sense since spago, as a “sub package manager” also downloads dependencies. We might be able to solve this by adding =spago build --deps-only= to the yarn package:

#+begin_src nix
node-modules = pkgs.stdenv.mkDerivation rec {
  name = "raytracker-frontend-deps";

  src = pkgs.lib.cleanSource ./.;

  buildInputs = [
    pkgs.yarn
    easy-ps.spago
    easy-ps.purs-0_14_5
    pkgs.nodePackages.node-gyp-build
  ];

  buildPhase = ''
    yarn install --cache-folder . --use-yarnrc .yarnrc
    spago build --deps-only --global-cache=skip
  '';

  installPhase = ''
    mkdir -p $out
    cp -R node_modules $out/
    cp -R .spago $out/
  '';

  dontFixup = true;
  outputHashAlgo = "sha256";
  outputHashMode = "recursive";
  outputHash = pkgs.lib.fakeSha256;
};
#+end_src

However, this leads us to:

#+begin_example
spago:
Error: InternalException (HandshakeFailed (Error_Protocol ("certificate has unknown CA",True,UnknownCa)))
URL: https://github.com/purescript/package-sets/releases/download/psc-0.14.5-20211111/packages.dhall
#+end_example

which leads us to [[https://github.com/commercialhaskell/stack/issues/4509][this stack-related issue]] and to more frustration.

Okay, going /back/ to the =node2nix=, maybe we can sort this mess out. Last time we looked at that, we had the spago, =/= not writeable problem, and we realized that we needed =spago2nix=, so let’s just use that. Coming from [[https://github.com/justinwoo/spago2nix/issues/48][the issue hat provided an actual working example]], we can devise this Nix expression:

#+begin_src nix
  nixpkgs.stdenv.mkDerivation {
    name = "raytracker-frontend-concur";
    src = ./.;
    buildInputs = [
      nixpkgs.yarn
      easy-ps.purs-0_14_5
      easy-ps.spago
      # spago2nix!
      spagoPkgs.installSpagoStyle
      spagoPkgs.buildSpagoStyle
      spagoPkgs.buildFromNixStore
    ];
    buildPhase = ''
      install-spago-style
      build-spago-style src/*purs src/Raytracker/*purs

      ln -s ${nodeDependencies}/lib/node_modules ./node_modules
      export PATH="${nodeDependencies}/bin:$PATH"

      ./node_modules/.bin/parcel --version
      yarn run --offline parcel build index.html
    '';
    installPhase = ''
      mkdir -p $out
      cp dist/* $out/
    '';
  }
#+end_src

This code…actually works! And is an amalgamation of all we talked about: =node2nix=, the patched version of it, =spago2nix=…amazing!
